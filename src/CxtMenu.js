// Generated by CoffeeScript 2.1.1
(function() {
  // Context menu for cytoscape
  // ==========================

  // # Features
  // 1. context sensitive menu
  // 2. can customize menu filter
  // 3. add dynamic menu item
  // 4. support nested menu
  // 5. self contained. no other dependencies

  // # (if you want see uml in chrome browser install https://github.com/callin2/plantUML_everywhere )

  // css
  var CxtMenu, MODULE_NAME, UMD, addClass, defaultOption, hasClass, hide, isPromise, offset, parents, register, removeClass, removeDomElem, show, toggleClass;

  require('./cytoscape-context-menus.css');

  MODULE_NAME = "cyto-cxt-menu";

  // # Option
  // ```uml
  // @startsalt
  // {
  // {T
  //  + Option
  //  ++ menuSelectHandler : [Function]
  //  ++ menu : [Menu]
  //  +++ name : [String]
  //  +++ viewWhen : [Boolean|String|Function] optional default true
  //  +++ onselect : [Function] optional
  //  +++ submenu : [Array<Menu>] optional
  // }
  // }
  // @endsalt
  // ```

  // ## menuSelectHandler:
  // - type : `(event: {menuName: string, target: element}) => void`
  // - 메뉴를 선택했을때 호출되는 event handler. 어떤 메뉴를 선택해도 항상 호출된다. 그래서 event에 `menuName`을 포함하고 있다.

  // ## menu:
  // - type `string` | `object` | `promise<menu>` | `(cy)=>menu`
  //   - `string`
  //     - string인 경우 `menuSelectHandler`를  반드시 설정해야 한다. 그렇지 않으면 메뉴만 표시되고 메뉴를 선택해도 아무일도 일어나지 않는다.
  //       값이 4자리 이상 연속된 `-` 인 경우 divider를 표시한다. `object` type으로 표현할 경우 `{ name: string}` 과 동일하다
  //   - `object`
  //     - 기본적인 메뉴 데이타구조이다. `name`만 필수이고 나머지는 생략 가능하다.
  //     - `.name`: `string` 메뉴이름 필수항목
  //     - `.viewWhen`: `boolean|string|({target, cy})=>boolean`  우클릭 했을때 메뉴가 표시될지 말지 결정
  //       - `boolean` : true면 메뉴를 표시 false면 표시하지 않음
  //       - `string` : cytoscape selector 로 사용. 이벤트가 발생한 target element가 selector 표현에 해당하면 메뉴표시 아니면 표시안함.
  //       - `({target, cy})=>boolean` : function호출 결과가 true 이면 메뉴표시 아니면 표시안함.
  //     - `.onselect`: `(event)=>void` optional
  //       - 메뉴가 선택되었을때 onselect에 설정된 함수를 호출해 준다.
  //     - `.submenu` : `menu[] | promise<menu[]> | (event)=>menu[] ` optional
  //       - ``
  //   - `promise<menu>`
  //     - menu 를 resolve 하는 promise. ajax 호출 결과를 가지고 menu를 표시를 하는경우 유용하다.
  //   - `(cy)=>menu`
  //     - `menu`를 return 하는 함수. 동적으로 menu를 표시해야 할경우 유용하다.

  // # Option 기본값
  defaultOption = {
    menuSelectHandler: function(evt) {
      return console.log('context menu selected!', evt);
    },
    menu: {
      name: "----",
      submenu: [
        "menu #1",
        "----",
        {
          name: "menu #2",
          onselect: function(evt) {
            return console.log(evt,
        'hello from menu #2');
          }
        },
        {
          name: "node",
          viewWhen: 'node',
          submenu: ["node submenu #1",
        "node submenu #2"]
        },
        {
          name: "edge",
          viewWhen: (function(evt) {
            var base;
            return typeof (base = evt.target).isEdge === "function" ? base.isEdge() : void 0;
          }),
          submenu: function() {
            return ["edge submenu #1",
        "edge submenu #2"];
          }
        }
      ]
    }
  };

  // utility functions from http://youmightnotneedjquery.com/
  removeDomElem = function(el) {
    return el.parentNode.removeChild(el);
  };

  hasClass = function(el, clsName) {
    return el.classList.contains(clsName);
  };

  toggleClass = function(el, clsName) {
    return el.classList.toggle(clsName);
  };

  addClass = function(el, clsName) {
    return el.classList.add(clsName);
  };

  removeClass = function(el, clsName) {
    return el.classList.remove(clsName);
  };

  show = function(el) {
    return el.style.display = '';
  };

  hide = function(el) {
    return el.style.display = 'none';
  };

  parents = function(el, selector) {
    var ref;
    if ((ref = el.parentNode) != null ? ref.matches(selector) : void 0) {
      return el.parentNode;
    } else {
      return parents(el.parentNode, selector);
    }
  };

  offset = function(el) {
    var rect;
    rect = el.getBoundingClientRect();
    return {
      top: rect.top + document.body.scrollTop,
      left: rect.left + document.body.scrollLeft
    };
  };

  isPromise = function(obj) {
    return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
  };

  // for UMD. borrowed from https://gist.github.com/bcherny/6567138
  UMD = function(fn) {
    if (typeof exports === 'object') {
      return module.exports = fn;
    } else if (typeof define === 'function' && define.amd) {
      return define(MODULE_NAME, function() {
        return fn;
      });
    } else {
      return this[MODULE_NAME] = fn(typeof cytoscape !== "undefined" && cytoscape !== null ? cytoscape : null);
    }
  };

  // cytoscape에 익스텐션을 등록하는데 사용되는 함수
  register = function(cytoscape) {
    if (!cytoscape) {
      return;
    }
    return cytoscape('core', "cxtMenu", function(options = null) {
      var cy, ref;
      cy = this;
      if (options) {
        if ((ref = cy.scratch(MODULE_NAME)) != null) {
          if (typeof ref.destroy === "function") {
            ref.destroy();
          }
        }
        cy.scratch(MODULE_NAME, new CxtMenu(cy, options));
      }
      return cy.scratch(MODULE_NAME);
    });
  };

  // 레지스터 함수를 UMD 모듈로 등록
  UMD(register);

  // context menu class
  CxtMenu = class CxtMenu {
    constructor(cy1, options) {
      var base;
      this.cy = cy1;
      this.options = Object.assign({}, defaultOption, options);
      if ((base = this.options).menuTemplate == null) {
        base.menuTemplate = this._mkMenuContent;
      }
      //console.log("@cy.container().parentNode", @cy.container().parentNode)
      this.cxtMenuRootElem = document.createElement('div');
      document.body.appendChild(this.cxtMenuRootElem);
      addClass(this.cxtMenuRootElem, 'menu');
      addClass(this.cxtMenuRootElem, 'root');
      this.initEventHandler();
    }

    destroy() {
      this.cy = null;
      this.options = null;
      removeDomElem(this.cxtMenuRootElem);
      return this.cxtMenuRootElem = null;
    }

    // 메뉴 하나를 초기화 하는 함수. 서브 메뉴를 포함하는 경우 서브 메뉴의 개개 항목에 대해 이 함수를 재귀적으로 호출한다.
    // menu 정보를 바탕으로 dom 을 만들고 parentElem 에 추가 한다.

    // - `parentElem` [DomElement]
    // - `menu` [Menu]
    // - `menuDepth` [Number] default 1
    // - `noNeedNewElem` [Boolean]
    initMenu(parentElem, menu, menuDepth = 1, noNeedNewElem = false) {
      var _rootEl, i, j, len, len1, m, ref, ref1, viewWhen;
      if (noNeedNewElem) {
        _rootEl = parentElem;
      } else {
        _rootEl = document.createElement('div');
        addClass(_rootEl, "menu");
        parentElem.appendChild(_rootEl);
      }
      console.log('_rootEl', _rootEl);
      if (typeof menu === 'string') {
        //-------------------------------------------------------------
        menu = {
          name: menu,
          viewWhen: true
        };
      }
      if (typeof menu === 'function') {
        this.initMenu(_rootEl, menu(this.cy), menuDepth, true);
      } else if (isPromise(menu)) {
        menu.then((mnu) => {
          return this.initMenu(_rootEl, mnu, menuDepth, true);
        }).catch(function(err) {
          return console.error("error in  menu info!", err);
        });
      } else if (menu instanceof Object) {
        viewWhen = this._checkViewWhen(menu);
        if (!viewWhen) {
          return removeDomElem(_rootEl);
        }
        _rootEl.innerHTML = this.options.menuTemplate.call(this, menu);
        addClass(_rootEl, "depth_" + menuDepth);
        _rootEl.__menu = menu;
        if (menu.submenu) {
          addClass(_rootEl, "menugroup");
          addClass(_rootEl, "fold");
          if (isPromise(menu.submenu)) {
            menu.submenu.then((mlist) => {
              var i, len, m, results;
              results = [];
              for (i = 0, len = mlist.length; i < len; i++) {
                m = mlist[i];
                results.push(this.initMenu(_rootEl, m, menuDepth + 1));
              }
              return results;
            }).catch(function(err) {
              return console.error("error in  menu info!", err);
            });
          } else if (typeof menu.submenu === 'function') {
            ref = menu.submenu(this.cy);
            for (i = 0, len = ref.length; i < len; i++) {
              m = ref[i];
              this.initMenu(_rootEl, m, menuDepth + 1);
            }
          } else if (menu.submenu instanceof Array) {
            ref1 = menu.submenu;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              m = ref1[j];
              this.initMenu(_rootEl, m, menuDepth + 1);
            }
          } else {
            console.error('unsupported submenu type', menu.submenu);
          }
        }
      }
      return _rootEl;
    }

    initEventHandler() {
      this.cy.on('cxttap', this._cxtTapHandler.bind(this));
      this.cy.on('tapstart', this._hideCxtMenu.bind(this));
      return this.cxtMenuRootElem.addEventListener('click', () => {
        return this._menuSelectHandler(window.event);
      });
    }

    _checkViewWhen(menu) {
      var evt;
      if (menu.viewWhen === void 0) {
        return true;
      }
      if (typeof menu.viewWhen === 'boolean') {
        return menu.viewWhen;
      }
      if (typeof menu.viewWhen === 'function') {
        return menu.viewWhen(this.cy.scratch('cxtEvent'));
      } else if (typeof menu.viewWhen === 'string') {
        evt = this.cy.scratch('cxtEvent');
        if (menu.viewWhen === 'core') {
          return evt.cy === evt.target;
        }
        return evt.target.filter(menu.viewWhen).size() === 1;
      } else {
        return console.error('.viewWhen type error', menu.viewWhen);
      }
    }

    _hideCxtMenu() {
      hide(this.cxtMenuRootElem);
      if (this._tmp_menu_root) {
        removeDomElem(this._tmp_menu_root);
      }
      return this._tmp_menu_root = null;
    }

    _cxtTapHandler(event) {
      var containerPos, left, renderedPos, top;
      console.log(event);
      this.cy.scratch('cxtEvent', event);
      if (this._tmp_menu_root) {
        removeDomElem(this._tmp_menu_root);
      }
      this._tmp_menu_root = this.initMenu(this.cxtMenuRootElem, this.options.menu);
      removeClass(this._tmp_menu_root, 'fold');
      containerPos = offset(this.cy.container());
      renderedPos = event.renderedPosition;
      left = containerPos.left + renderedPos.x;
      top = containerPos.top + renderedPos.y;
      this.cxtMenuRootElem.style.left = left + 'px';
      this.cxtMenuRootElem.style.top = top + 'px';
      return show(this.cxtMenuRootElem);
    }

    _menuSelectHandler(event) {
      var base, menuItemParent;
      if (hasClass(event.target, 'groupname')) {
        return toggleClass(event.target.parentElement, 'fold');
      } else if (hasClass(event.target, 'item')) {
        this.options.menuSelectHandler({
          menuName: event.target.textContent,
          target: this.cy.scratch('cxtEvent').target
        });
        menuItemParent = parents(event.target, '.menu');
        if (typeof (base = menuItemParent.__menu).onselect === "function") {
          base.onselect({
            menuName: event.target.textContent,
            target: this.cy.scratch('cxtEvent').target
          });
        }
        return hide(this.cxtMenuRootElem);
      }
    }

    // `menuInfo`를 가지고 html string 만드든 template 함수
    _mkMenuContent(menuInfo) {
      if (menuInfo.name.startsWith('----')) {
        return "<div class='divider'></div>";
      } else {
        return `<button class='item ${(menuInfo.submenu ? 'groupname' : '')}'>${menuInfo.name}</button>`;
      }
    }

  };

}).call(this);
